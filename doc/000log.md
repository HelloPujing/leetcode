# 日志
2023-3-16: 开始经典第一题。我哥逼我要求高一点，第一天不要只搭环境，直接做一题；且让我坚持，说哪天不做他就加烟哈哈哈。开始学用VSCode。
2023-3-17: 学会了时间/空间复杂度。以及，VSCode连git。用`ts --init`创建tsconfig配置文件
2023-3-19: 学会了复杂度log10n，学会了!
2023-3-20: 学会了vscode调试ts代码；解决了npm registry，之前还是kjl的；npm init给项目初始化安装ts & ts-node，让ts不用编译成js就能运行
2023-3-24: 学了分治算法（一般用递归实现）
2023-3-27: 使用了链表和递归
2023-3-28: 使用了栈，栈需要自己用数组实现
2023-3-30: 使用了二分查找，注意用位运算代替除法效率更高
2023-4-2: 调试报错，/usr/local/bin/node -r ts-node/register 失败，最后安装最新版node后成功
2023-4-11: 第一次使用二叉树
2023-4-12: 第一次接触二叉搜索树
2023-4-17: 第一次接触快慢指针，龟兔赛跑重合判断环链表，省去哈希存储
2023-4-18: 又一次接触快慢指针，链表取中间值的好方法
2023-4-19: 数组，有时候，用arr[0]和subArr的角度看待问题，不如用arr[n]和subArr[0,n]的角度看待问题
2023-4-19: 第一次接触贪心算法
2023-4-25: vscode插件git graph
2023-4-27: 第一次做矩阵，旋转=两次翻转
2023-5-09: 第一次接触s.charCodeAt
2023-5-15: 第一次接触KMP，太难了... 以后再来


# 数据结构和算法总结
- 数组：
    - 基础：
        - 头，unshift/shift
        - 尾，push
    - 哈希表，Map、Set
    - 二分查找，log2底n
    - DP, logn (121) | O(n)（53, 198） 
    - 双指针 (1)
    - 贪心算法 (36)
- 字符串：
    - 哈希表，Map、Set
    - 双指针  (125)
    - 移动窗口 （3）
    - 二分查找，log2底n
    - DP, logn （1567）
    - 贪心算法
    - 翻转取余（7）
    - KMP取子串，太难了 （28）
- 链表：
    - 递归（2, 103）
    - 双指针 (19)
    - 快慢指针 (141, 234)

- 二叉树：
    - 分治
    - 遍历(深度优先后序/前序/中序遍历，广度优先)
        - BFS，用链表，用途：层序遍历、(无权)最短路径，（102）
            - 延伸：Dijkstra算法，带权最短路径 
            - 网格BFS
            - 多源BFS
            - 可做：103 199 515 637
        - DFS，递归，书写简单、空间复杂度更小 (98, 101, 104)

- 类：
    - 内部先定义变量类型，构造器里赋值（384, 155）



数学题：
- Math.pow 
- Math.trunc 舍去小数点
- Math.random * num, num是想取随机数的范围（384）
- 质数，埃氏筛(204不熟)
- &与运算，都是1才1；n &= n - 1,可以用来测算汉明重量


# 数据结构总结
哈希：
ts中，map和set都可以用哈希表来实现
    - 相同点：都经过计算哈希码来存储，快速索引
    - 不同点：map存储键值对，对键计算哈希码；set存储唯一值，对值计算哈希码

遍历：
- 数组、字符串、对象的遍历
- 注意forEach不能中断一定会循环结束，其他迭代方法都能中断（break/continue/return）
- 数组：for forof foreach map
- 字串：for forof Array.from.forEach Array.split.forEach
- 对象：forin keys values entries

数组：
- splice返回切割的数组，但原数组被切掉了
- slice返回切割的数组，但原数组不变
- 循环试试从后往前

单调栈：
单调栈实际上就是栈，只是再新元素压栈之前要从栈顶扫描一遍栈，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。
听起来有点像堆（heap）？不是的，单调栈的限制条件更高，所以效率高但用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」等。
现在还没有形成“先分析问题抽象出类似下一个更大元素这种建模结果，然后找对应可以解决这类数学模型的算法或者数据结构”的习惯，可能是没有系统性地练习
优先级队列就是堆


# 刷题步骤
- 初级、中级、高级：
    - 各50题左右
- 类型，都包含：
    - 数组字符串、链表、树和图、回溯算法、排序和搜索、dp、设计问题、数学
- 来源：
    - 按照leetcode官方整理的三类难度题库


# todo
70题，easy，还可以用矩阵快速幂 & 通向共识 再求一次
